Class {
	#name : #GtCreationForm,
	#superclass : #Object,
	#instVars : [
		'onAccept',
		'packageAndTagName',
		'onElementCreated',
		'onReset'
	],
	#category : #'GToolkit-Coder-UI-Forms - Models'
}

{ #category : #accessing }
GtCreationForm class >> componentName [
	^ self subclassResponsibility
]

{ #category : #accessing }
GtCreationForm class >> isAdditionForm [
	^ true
]

{ #category : #accessing }
GtCreationForm class >> priority [
	^ self subclassResponsibility
]

{ #category : #magritte }
GtCreationForm >> acceptAction [
	<magritteActionDescription>
	^ MAActionDescription new
		label: 'Accept';
		action: [ :aModel :aButton | 
			aButton
				inUIProcessDo: [ [ | aValue |
					aValue := self commit.
					onAccept ifNotNil: [ onAccept value: aValue ] ] on: Error do: #debug ] ];
		beCommitAction
]

{ #category : #converting }
GtCreationForm >> asElement [
	| viewModel |
	viewModel := self asGtMagritteViewModel.
	self onElementCreated
		ifNotNil: [ :aCallback | viewModel onElementCreated: aCallback ].
	"save and cancel actions should be available even if unchanged"
	viewModel actions first
		installOn: [ :aModel :aButton :aMemento | 
			aButton
				withAsyncSinkDo: [ :anElementSink | 
					anElementSink
						sink: AsyncPeekSink new;
						whenUpdate: [ :theButton :aSink | 
							| aStatus |
							aStatus := aSink value.
							theButton enabled: aStatus isValid ].
					aMemento overallStatus observe: anElementSink ] ].
	viewModel actions second
		installOn: [ :aModel :aButton :aMemento | 
			aButton
				withAsyncSinkDo: [ :anElementSink | 
					anElementSink
						sink: AsyncPeekSink new;
						whenUpdate: [ :theButton :aSink | 
							theButton enabled: true ].
					aMemento overallStatus observe: anElementSink ] ].
	^ viewModel asElement
]

{ #category : #magritte }
GtCreationForm >> cancelAction [
	<magritteActionDescription>
	^ MAActionDescription new
		label: 'Reset';
		action: [ :aModel :aButton | [ onReset ifNotNil: [ onReset value ] ] on: Error do: #debug ];
		beResetAction
]

{ #category : #callbacks }
GtCreationForm >> commit [
	^ self subclassResponsibility
]

{ #category : #callbacks }
GtCreationForm >> commitPackage [
	| aPackage |
	(RPackageOrganizer default includesPackageNamed: packageAndTagName packageName)
		ifTrue: [ aPackage := RPackageOrganizer default
					packageNamed: packageAndTagName packageName.
			^ packageAndTagName tagName
				ifEmpty: [ aPackage ]
				ifNotEmpty: [ :aTagName | aPackage classTagNamed: aTagName ifAbsent: [ aPackage addClassTag: aTagName ] ] ]
		ifFalse: [ aPackage := (RPackage named: packageAndTagName packageName)
					register.
			^ packageAndTagName tagName
				ifEmpty: [ aPackage ]
				ifNotEmpty: [ :aTagName | aPackage addClassTag: aTagName ] ]
]

{ #category : #accessing }
GtCreationForm >> ghostTextFor: aString [
	^ BrGhostTextAttribute
		for: (aString asRopedText glamorousFormEditorCodeFontAndSize foreground: Color lightGray)
]

{ #category : #accessing }
GtCreationForm >> hasPackageAndTag [
	^ true
]

{ #category : #initialization }
GtCreationForm >> initialize [
	packageAndTagName := GtPackageAndTagName new
]

{ #category : #accessing }
GtCreationForm >> onAccept [

	^ onAccept
]

{ #category : #accessing }
GtCreationForm >> onAccept: anObject [

	onAccept := anObject
]

{ #category : #accessing }
GtCreationForm >> onElementCreated [
	^ onElementCreated
]

{ #category : #accessing }
GtCreationForm >> onElementCreated: anObject [
	onElementCreated := anObject
]

{ #category : #accessing }
GtCreationForm >> onReset [
	^ onReset
]

{ #category : #accessing }
GtCreationForm >> onReset: anObject [
	onReset := anObject
]

{ #category : #accessing }
GtCreationForm >> packageAndTagDescription [
	<magritteDescription>
	^ GtPackageAndTagDescription new
		label: 'Package';
		priority: 3;
		accessor: #packageAndTagName;
		editorAptitude: [ BrGlamorousRegularEditorAptitude new glamorousFormEditorCodeFontAndSize ];
		labelAptitude: [ BrGlamorousLabelAptitude new glamorousFormLabelStyle ];
		beRequired
]

{ #category : #accessing }
GtCreationForm >> packageAndTagName [

	^ packageAndTagName
]

{ #category : #accessing }
GtCreationForm >> packageAndTagName: anObject [

	packageAndTagName := anObject
]

{ #category : #accessing }
GtCreationForm >> selectInNavigationModel: aNavigationModel anInstance: anInstance [
	^ aNavigationModel selectClass: anInstance
]

{ #category : #accessing }
GtCreationForm >> taggerStencilWithCompletion: aCompletionStrategy andContextMenuBlock: aContextMenuBlock [
	^ [ :aMemento :aDescription :aForm | 
	| aTagger aTaggerAptitude |
	aTagger := BrTagger new hFitContentLimited.
	aForm hMatchParent.
	aTagger
		padding: (BlInsets top: -2 bottom: 5);
		clipChildren: false;
		aptitude: (aTaggerAptitude := GtCreationEditableTaggerAptitude new
					margin: (BlInsets
							top: 0
							bottom: 3
							left: 0
							right: 5);
					tagLabel: [ :aTag | 
						| aLabel |
						aLabel := BrEditableLabel new
								text: (aDescription displayStringFor: aTag name);
								aptitude: (BrGlamorousEditableLabelAptitude new glamorousFormEditorCodeFontAndSize
										defaultForeground: Color black).

						aDescription blocShortcuts
							ifNotNil: [ :aBlockReturningCollection | 
								aBlockReturningCollection value
									do: [ :aShortcut | aLabel addShortcut: aShortcut ] ].

						aLabel when: BlClickEvent do: [ :anEvent | aLabel switchToEditor ].

						aCompletionStrategy
							ifNotNil: [ (GtCompletionController on: aLabel strategy: aCompletionStrategy) install ].
						aContextMenuBlock
							ifNotNil: [ aLabel
									addAptitude: (BrGlamorousWithContextMenuAptitude
											content: [ aContextMenuBlock value: aTag name value: aLabel ]) ].
						aLabel ]).
	aTagger
		when: BrTaggerAddTagRequest
		do: [ :aRequest | 
			aTagger
				enqueueTask: (BlPromiseTask new
						promise: (aMemento
								write: ((aTagger tags collect: #name)
										add: aRequest tag name;
										yourself)
								using: aDescription) asAsyncPromise) ].
	aTagger
		when: BrTaggerRemoveTagRequest
		do: [ :aRequest | 
			aTagger
				enqueueTask: (BlPromiseTask new
						promise: (aMemento
								write: ((aTagger tags collect: #name)
										remove: aRequest tag name;
										yourself)
								using: aDescription) asAsyncPromise).
			aTaggerAptitude addTagCreatorElement ].
	aTagger
		withAsyncSinkDo: [ :anElementSink | 
			anElementSink
				sink: AsyncPeekSink new;
				whenUpdate: [ :theTagger :aSink | 
					| theValues |
					theValues := aSink value currentValue.
					theTagger namedTags: theValues ].
			(aMemento readObservableValueUsing: aDescription) observe: anElementSink ].
	GtMagritteBuilderUtility
		newValidationContainerWith: aTagger
		memento: aMemento
		using: aDescription ]
]

{ #category : #accessing }
GtCreationForm >> toolFor: anInstance [
	^ GtClassCoderTool forClass: anInstance
]
